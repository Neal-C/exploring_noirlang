{"noir_version":"0.34.0+359caafac5e489901d9ff02b08d1a688178d9b0a","hash":7232007939528526494,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"7drNbtpAFEDhd5k1C58Zzx+vUlURJCSyhCACUqlCvHtNGqoqZXO6znLgXsvweXXkc3jarN9eHqbd8/4Ylt/OYbt/XJ2m/W4+ncPw/tHxdbW7no6n1eEUlmNehM3uKSwzl0V4nrabsKzx8n0RcOPRjSc3PrrxfG88t4/x2v8eX/wzWHv5mGyx/RlN9Xrlcu/K7XYjtOF/Lz0f1odpu51eHj6rncN499+tQ739onH4dJ9j0huj3sh6o+iNqjea3uh2Iw96A72hzbM2z9o8a/OszbM2z9o8a/OizYs2L9q8aPOizYs2L9q8aPOizYs2r9q8avOqzas2r9q8avOqzas2r9q8avOmzZs2b9q8afOmzZs2b9q8afOmzZs279q8a/Ouzbs279q8a/Ouzbs279q8a3OGwa/gV6JfSX5l9CvZrxS/Uv1K8yteH6+P18fr4/Xx+nh9vD5eH6+P149eP3r96PWj149eP3r9KPUv7wXp/PXYfD02dsXrR68fvX7y+snrJ6+fvH7y+snrJ6+fvH7y+snrj15/9Pq+9OJTL7714mMvvvbicy++9+KDL7744pMvvvnioy+++uKzL7774sMvvvzi0y++/eLjL77+4vMvvv/iAzC+AOMTML4B4yMwvgLjMzC+A+NDML4E41MwvgXjYzC+BuNzML4H44MwvgjjkzC+CeOjML4K47MwvgvjwzC+DOPTML4N4+Mwvg7j8zC+D+MDMb4Q4xNxtIn4Mp9+rA7Tar3dXN/euH75tnu8vcwxH08/X39/Mw//Ag==","file_map":{"37":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\nmod meta;\nmod append;\nmod mem;\nmod panic;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32\n) {\n    crate::assert_constant(proof_type);\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"72":{"source":"fn main(x: Field, y: pub Field) {\n    assert(x != y);\n    println(\"Flex. üòé\");\n    println(\"Let the records show that I was coding in noir before it was cool & maintsream. üòè\");\n}\n\n#[test]\nfn test_main() {\n    main(1, 2);\n\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n","path":"/home/b/Documents/dev/explored/exploring_noirlang/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","directive_invert"]}